<!DOCTYPE html>
<html lang="en" data-accent-color="indigo" data-content_root="../../">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>The Python Language Summit 2023: Pattern Matching, __match__, and View Patterns - Python Blog</title><link rel="shortcut icon" href="../../_static/badge.svg"/><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><script>
    function setColorMode(t){let e=document.documentElement;e.setAttribute("data-color-mode",t);let a=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,s=t;"auto"===t&&(s=a?"dark":"light"),"light"===s?(e.classList.remove("dark"),e.classList.add("light")):(e.classList.remove("light"),e.classList.add("dark"))}
    setColorMode(localStorage._theme||"auto");
  </script><link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=397bb51e" />
    <link rel="stylesheet" type="text/css" href="../../_static/shibuya.css?v=301e5329" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=87e54e7c" />
    <link media="print" rel="stylesheet" type="text/css" href="../../_static/print.css?v=20ff2c19" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --sy-f-text: "Inter", var(--sy-f-sys), var(--sy-f-cjk), sans-serif;
  --sy-f-heading: "Inter", var(--sy-f-sys), var(--sy-f-cjk), sans-serif;
}
</style>
    



</head>
<body><div class="sy-head">
  <div class="sy-head-blur"></div>
  <div class="sy-head-inner sy-container mx-auto">
    <a class="sy-head-brand" href="/">
      <img class="light-logo" src="../../_static/badge.svg" alt="Python Blog" height="28" loading="lazy" />
      <img class="dark-logo" src="../../_static/badge.svg" alt="Python Blog" height="28" loading="lazy" />
      <strong>Python Blog</strong>
    </a>
    <div class="sy-head-nav" id="HeadNav">
      <nav class="sy-head-links"><ul><li class="link"><a href="../../index.html">Home</a></li>
      <li class="link"><button type="button">
            <span>Community</span>
            <i class="i-lucide chevron-down"></i>
          </button>
        <ul><li><a href="https://www.python.org/dev/">
                <span>Contributing</span>
                <small>Learn how to contribute to the Python project</small>
              </a></li><li><a href="https://policies.python.org/python.org/code-of-conduct/">
                <span>Code of Conduct</span>
                <small>Review the etiquette for interacting with the Python community</small>
              </a></li><li><a href="https://www.python.org/dev/security/">
                <span>Security</span>
                <small>Overview of PSFs's security protocols</small>
              </a></li></ul>
      </li>
      <li class="link"><button type="button">
            <span>About</span>
            <i class="i-lucide chevron-down"></i>
          </button>
        <ul><li><a href="https://www.python.org/psf-landing/">
                <span>Python Software Foundation</span>
                <small>Details about the PSF</small>
              </a></li><li><a href="https://www.python.org/downloads/">
                <span>Releases</span>
                <small>Explore the latest Python releases</small>
              </a></li></ul>
      </li>
      <li class="link"><button type="button">
            <span>Help</span>
            <i class="i-lucide chevron-down"></i>
          </button>
        <ul><li><a href="https://discord.gg/python">
                <span>Discord Help Forum</span>
                <small>Dedicated Discord help forum</small>
              </a></li><li><a href="https://discuss.python.org/">
                <span>Board Discussions</span>
                <small>Board Discussions</small>
              </a></li></ul>
      </li><li class="link">
          <a href="https://github.com/sponsors/python">
            <span>Sponsor</span></a>
        </li></ul></nav>
      <div class="sy-head-extra flex items-center print:hidden"><form class="searchbox flex items-center" action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <kbd>/</kbd>
</form><div class="sy-head-socials"></div></div>
    </div>
    <div class="sy-head-actions flex items-center shrink-0 print:hidden"><button class="js-theme theme-switch flex items-center"
data-aria-auto="Switch to light color mode"
data-aria-light="Switch to dark color mode"
data-aria-dark="Switch to auto color mode">
<i class="i-lucide theme-icon"></i>
</button><button class="md:hidden flex items-center js-menu" aria-label="Menu" type="button" aria-controls="HeadNav" aria-expanded="false">
        <div class="hamburger">
          <span class="hamburger_1"></span>
          <span class="hamburger_2 -translate-x-2"></span>
          <span class="hamburger_3 -translate-x-1"></span>
        </div>
      </button>
    </div>
  </div>
</div><div class="sy-container mx-auto body">
    <main class="sy-content mx-auto pt-12 px-6 xl:px-12 break-words">
      <article class="yue" role="main">
        
<section id="the-python-language-summit-2023-pattern-matching-match-and-view-patterns">
<h1>The Python Language Summit 2023: Pattern Matching, __match__, and View Patterns<a class="headerlink" href="#the-python-language-summit-2023-pattern-matching-match-and-view-patterns" title="Link to this heading">¶</a></h1>
<p><em>This was originally posted on blogger</em> <a class="reference external" href="https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-pattern.html">here</a>.</p>
<p>One of the most exciting new features in Python 3.10 was <a class="reference external" href="https://docs.python.org/3/whatsnew/3.10.html#pep-634-structural-pattern-matching">the introduction of
pattern
matching</a> (introduced in PEPs
<a class="reference external" href="https://peps.python.org/pep-0634/">634</a>,
<a class="reference external" href="https://peps.python.org/pep-0635/">635</a> and
<a class="reference external" href="https://peps.python.org/pep-0636/">636</a>). Pattern matching has a wide variety
of uses, but really shines in situations where you need to undergo complex
destructurings of tree-like datastructures.</p>
<p>That’s a lot of words which may or may not mean very much to you – but
consider, for example, using <cite>the `ast</cite>
module &lt;<a class="reference external" href="https://docs.python.org/3/library/ast.html">https://docs.python.org/3/library/ast.html</a>&gt;`_ to parse Python source
code. If you’re unfamiliar with the <cite>ast</cite> module: the module provides tools
that enable you to compile Python source code into an “abstract syntax tree”
(AST) representing the code’s structure. The Python interpreter itself
converts Python source code into an AST in order to understand how to run that
code – but parsing Python source code using ASTs is also a common task for
linters, such as plugins for <a class="reference external" href="https://flake8.pycqa.org/en/latest/">flake8</a> or
<a class="reference external" href="https://www.pylint.org">pylint</a>. In the following example, <cite>ast.parse()</cite> is
used to parse the source code <cite>x = 42</cite> into an <cite>ast.Module</cite> node, and
<cite>ast.dump()</cite> is then used to reveal the tree-like structure of that node in a
human-readable form:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span data-line="1"><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ast</span>
</span><span data-line="2"><span class="gp">&gt;&gt;&gt; </span><span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;x = 42&quot;</span>
</span><span data-line="3"><span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
</span><span data-line="4"><span class="gp">&gt;&gt;&gt; </span><span class="n">node</span>
</span><span data-line="5"><span class="go">&lt;ast.Module object at 0x000002A70F928D80&gt;</span>
</span><span data-line="6"><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</span><span data-line="7"><span class="go">Module(</span>
</span><span data-line="8"><span class="go">  body=[</span>
</span><span data-line="9"><span class="go">    Assign(</span>
</span><span data-line="10"><span class="go">      targets=[</span>
</span><span data-line="11"><span class="go">        Name(id=&#39;x&#39;, ctx=Store())],</span>
</span><span data-line="12"><span class="go">      value=Constant(value=42))],</span>
</span><span data-line="13"><span class="go">  type_ignores=[])</span>
</span></pre></div>
</div>
<p>How does working with ASTs relate to pattern-matching? Well, a function to
determine whether (to a reasonable approximation) an arbitrary AST node
represents the symbol <cite>collections.deque</cite> might have looked something like
this, before pattern matching…</p>
<blockquote>
<div><p>import ast</p>
<p># This obviously won’t work if the symbol is imported with an alias
# in the source code we’re inspecting
# (e.g. “from collections import deque as d”).
# But let’s not worry about that here :-)</p>
<dl>
<dt>def node_represents_collections_dot_deque(node: ast.AST) -&gt; bool:</dt><dd><p>“””Determine if <em>node</em> represents ‘deque’ or ‘collections.deque’”””
return (</p>
<blockquote>
<div><p>isinstance(node, ast.Name) and node.id == “deque”</p>
</div></blockquote>
<dl class="simple">
<dt>) or (</dt><dd><p>isinstance(node, ast.Attribute)
and isinstance(node.value, ast.Name)
and node.value.id == “collections”
and node.value.attr == “deque”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>But in Python 3.10, pattern matching allows an elegant destructuring syntax:</p>
<blockquote>
<div><p>import ast</p>
<dl>
<dt>def node_represents_collections_dot_deque(node: ast.AST) -&gt; bool:</dt><dd><p>“””Determine if <em>node</em> represents ‘deque’ or ‘collections.deque’”””
match node:</p>
<blockquote>
<div><dl class="simple">
<dt>case ast.Name(“deque”):</dt><dd><p>return True</p>
</dd>
<dt>case ast.Attribute(ast.Name(“collections”), “deque”):</dt><dd><p>return True</p>
</dd>
<dt>case _:</dt><dd><p>return False</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>I know which one _I_ prefer.</p>
<p>For some, though, this still isn’t enough – and Michael “Sully” Sullivan is
one of them. At the <a class="reference external" href="https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023_29.html">Python Language Summit
2023</a>, Sullivan shared ideas for where pattern matching could
go next.</p>
<ul class="simple">
<li><ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<section id="playing-with-matches-without-getting">
<h2>Playing with matches (<a href="#id4"><span class="problematic" id="id5">`</span></a>without getting<a class="headerlink" href="#playing-with-matches-without-getting" title="Link to this heading">¶</a></h2>
<p>burned &lt;<a class="reference external" href="https://www.youtube.com/watch?v=DJeMfTdvVo8">https://www.youtube.com/watch?v=DJeMfTdvVo8</a>&gt;`_)</p>
<p>Sullivan’s contention is that, while pattern matching provides elegant
syntactic sugar in simple cases such as the one above, our ability to chain
destructurings using pattern matching is currently fairly limited. For
example, say we want to write a function inspecting Python AST that takes an
<cite>ast.FunctionDef</cite> node and identifies whether the node represents a
synchronous function with exactly two parameters, both of them annotated as
accepting integers. The function would behave so that the following holds
true:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span data-line="1"><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ast</span>
</span><span data-line="2"><span class="gp">&gt;&gt;&gt; </span><span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;def add_2(number1: int, number2: int): pass&quot;</span>
</span><span data-line="3"><span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span data-line="4"><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</span><span data-line="5"><span class="go">&lt;class &#39;ast.FunctionDef&#39;&gt;</span>
</span><span data-line="6"><span class="gp">&gt;&gt;&gt; </span><span class="n">is_function_taking_two_ints</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</span><span data-line="7"><span class="go">True</span>
</span></pre></div>
</div>
<p>With pre-pattern-matching syntax, we might have written such a function like
this:</p>
<blockquote>
<div><dl>
<dt>def is_int(node: ast.AST | None) -&gt; bool:</dt><dd><p>“””Determine if <em>node</em> represents ‘int’ or ‘builtins.int’”””
return (</p>
<blockquote>
<div><p>isinstance(node, ast.Name) and node.id == “int”</p>
</div></blockquote>
<dl class="simple">
<dt>) or (</dt><dd><p>isinstance(node, ast.Attribute)
and isinstance(node.value, ast.Name)
and node.value.id == “builtins”
and node.attr == “int”</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def is_function_taking_two_ints(node: ast.FunctionDef) -&gt; bool:</dt><dd><p>“””Determine if <em>node</em> represents a function that accepts two ints”””
args = node.args.posonlyargs + node.args.args
return len(args) == 2 and all(is_int(node.annotation) for node in args)</p>
</dd>
</dl>
</div></blockquote>
<p>If we wanted to rewrite this using pattern matching, we could possibly do
something like this:</p>
<blockquote>
<div><dl>
<dt>def is_int(node: ast.AST | None) -&gt; bool:</dt><dd><p>“””Determine if <em>node</em> represents ‘int’ or ‘builtins.int’”””
match node:</p>
<blockquote>
<div><dl class="simple">
<dt>case ast.Name(“int”):</dt><dd><p>return True</p>
</dd>
<dt>case ast.Attribute(ast.Name(“builtins”), “int”):</dt><dd><p>return True</p>
</dd>
<dt>case _:</dt><dd><p>return False</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>def is_function_taking_two_ints(node: ast.FunctionDef) -&gt; bool:</dt><dd><p>“””Determine if <em>node</em> represents a function that accepts two ints”””
match node.args.posonlyargs + node.args.args:</p>
<blockquote>
<div><dl class="simple">
<dt>case [ast.arg(), ast.arg()] as arglist:</dt><dd><p>return all(is_int(arg.annotation) for arg in arglist)</p>
</dd>
<dt>case _:</dt><dd><p>return False</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>That leaves a lot to be desired, however! The <cite>is_int()</cite> helper function can
be rewritten in a _much_ cleaner way. But integrating it into the
<cite>is_function_taking_two_ints()</cite> is… somewhat icky! The code feels _harder_ to
understand than before, whereas the goal of pattern matching is to improve
readability.</p>
<p>Something like this, (ab)using metaclasses, gets us a lot closer to what it
feels pattern matching _should_ be like. By using one of Python’s hooks for
customising <cite>isinstance()</cite> logic, it’s possible to rewrite our <cite>is_int()</cite>
helper function as a class, meaning we can seamlessly integrate it into our
<cite>is_function_taking_two_ints()</cite> function in a very expressive way:</p>
<blockquote>
<div><p>import abc
import ast</p>
<dl>
<dt>class PatternMeta(abc.ABCMeta):</dt><dd><dl class="simple">
<dt>def __instancecheck__(cls, inst: object) -&gt; bool:</dt><dd><p>return cls.match(inst)</p>
</dd>
</dl>
</dd>
<dt>class Pattern(metaclass=PatternMeta):</dt><dd><p>“””Abstract base class for types representing ‘abstract patterns’”””
&#64;staticmethod
&#64;abc.abstractmethod
def match(node) -&gt; bool:</p>
<blockquote>
<div><p>“””Subclasses must override this method”””
raise NotImplementedError</p>
</div></blockquote>
</dd>
<dt>class int_node(Pattern):</dt><dd><p>“””Class representing AST patterns signifying <cite>int</cite> or <cite>builtins.int</cite>”””
&#64;staticmethod
def match(node) -&gt; bool:</p>
<blockquote>
<div><dl class="simple">
<dt>match node:</dt><dd><dl class="simple">
<dt>case ast.Name(“int”):</dt><dd><p>return True</p>
</dd>
<dt>case ast.Attribute(ast.Name(“builtins”), “int”):</dt><dd><p>return True</p>
</dd>
<dt>case _:</dt><dd><p>return False</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>def is_function_taking_two_ints(node: ast.FunctionDef) -&gt; bool:</dt><dd><p>“””Determine if <em>node</em> represents a function that accepts two ints”””
match node.args.posonlyargs + node.args.args:</p>
<blockquote>
<div><dl class="simple">
<dt>case [</dt><dd><p>ast.arg(annotation=int_node()),
ast.arg(annotation=int_node()),</p>
</dd>
<dt>]:</dt><dd><p>return True</p>
</dd>
<dt>case _:</dt><dd><p>return False</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>This is still hardly ideal, however – that’s a lot of boilerplate we’ve had to
introduce to our helper function for identifying <cite>int</cite> annotations! And who
wants to muck about with metaclasses?</p>
<p><a class="reference external" href="https://blogger.googleusercontent.com/img/a/AVvXsEjz18FEpI2W8Dx9w0LUFcj4KhCu2ml9sKxdPh33P6IBGuLx65qgBsTMJTwHPXtX7CzPYtkL81sxGJv8RJ8RQlCwKKkGy7epUxp4io7PRMeO6_ZAWF1yvlWqtg6cEiGtwhcRUl-8F7g8M3p8jwKK2b-9YHEbaacoz8OUi4LglXSPXvo3maY">![</a>](<a class="reference external" href="https://blogger.googleusercontent.com/img/a/AVvXsEjz18FEpI2W8Dx9w0LUFcj4KhCu2ml9sKxdPh33P6IBGuLx65qgBsTMJTwHPXtX7CzPYtkL81sxGJv8RJ8RQlCwKKkGy7epUxp4io7PRMeO6_ZAWF1yvlWqtg6cEiGtwhcRUl-8F7g8M3p8jwKK2b-9YHEbaacoz8OUi4LglXSPXvo3maY">https://blogger.googleusercontent.com/img/a/AVvXsEjz18FEpI2W8Dx9w0LUFcj4KhCu2ml9sKxdPh33P6IBGuLx65qgBsTMJTwHPXtX7CzPYtkL81sxGJv8RJ8RQlCwKKkGy7epUxp4io7PRMeO6_ZAWF1yvlWqtg6cEiGtwhcRUl-8F7g8M3p8jwKK2b-9YHEbaacoz8OUi4LglXSPXvo3maY</a>)
—
A slide from Sullivan’s talk</p>
<ul class="simple">
<li><ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="a-match-made-in-heaven">
<h2>A <cite>__match__</cite> made in heaven?<a class="headerlink" href="#a-match-made-in-heaven" title="Link to this heading">¶</a></h2>
<p>Sullivan proposes that we make it easier to write helper functions for pattern
matching, such as the example above, without having to resort to custom
metaclasses. Two competing approaches were brought for discussion.</p>
<p>The first idea – a <cite>__match__</cite> special method – is perhaps the easier of the
two to immediately grasp, and appeared in early drafts of the pattern matching
PEPs. (It was eventually removed from the PEPs in order to reduce the scope of
the proposed changes to Python.) The proposal is that any class could define a
<cite>__match__</cite> method that could be used to customise how match statements apply
to the class. Our <cite>is_function_taking_two_ints()</cite> case could be rewritten like
so:</p>
<blockquote>
<div><dl>
<dt>class int_node:</dt><dd><p>“””Class representing AST patterns signifying <cite>int</cite> or <cite>builtins.int</cite>”””
# The __match__ method is understood by Python to be a static method,
# even without the &#64;staticmethod decorator,
# similar to __new__ and __init_subclass__
def __match__(node) -&gt; ast.Name | ast.Attribute:</p>
<blockquote>
<div><dl class="simple">
<dt>match node:</dt><dd><dl class="simple">
<dt>case ast.Name(“int”):</dt><dd><p># Successful matches can return custom objects,
# that can be bound to new variables by the caller
return node</p>
</dd>
<dt>case ast.Attribute(ast.Name(“builtins”), “int”):</dt><dd><p>return node</p>
</dd>
<dt>case _:</dt><dd><p># Return <cite>None</cite> to indicate that there was no match
return None</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>def is_function_taking_two_ints(node: ast.FunctionDef) -&gt; bool:</dt><dd><p>“””Determine if <em>node</em> represents a function that accepts two ints”””
match node.args.posonlyargs + node.args.args:</p>
<blockquote>
<div><dl class="simple">
<dt>case [</dt><dd><p>ast.arg(annotation=int_node()),
ast.arg(annotation=int_node()),</p>
</dd>
<dt>]:</dt><dd><p>return True</p>
</dd>
<dt>case _:</dt><dd><p>return False</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>The second idea is more radical: the introduction of some kind of new syntax
(perhaps reusing Python’s <cite>-&gt;</cite> operator) that would allow Python coders to
“apply” functions during pattern matching. With this proposal, we could
rewrite <cite>is_function_taking_two_ints()</cite> like so:</p>
<blockquote>
<div><dl>
<dt>def is_int(node: ast.AST | None) -&gt; bool:</dt><dd><p>“””Determine if <em>node</em> represents ‘int’ or ‘builtins.int’”””
match node:</p>
<blockquote>
<div><dl class="simple">
<dt>case ast.Name(“int”):</dt><dd><p>return True</p>
</dd>
<dt>case ast.Attribute(ast.Name(“builtins”), “int”):</dt><dd><p>return True</p>
</dd>
<dt>case _:</dt><dd><p>return False</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>def is_function_taking_two_ints(node: ast.FunctionDef) -&gt; bool:</dt><dd><p>“””Determine if <em>node</em> represents a function that accepts two ints”””
match node.args.posonlyargs + node.args.args:</p>
<blockquote>
<div><dl class="simple">
<dt>case [</dt><dd><p>ast.arg(annotation=is_int -&gt; True),
ast.arg(annotation=is_int -&gt; True),</p>
</dd>
</dl>
<p>]
case _:</p>
<blockquote>
<div><p>return False</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<ul class="simple">
<li><ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="match-maker-match-maker-make-me-a">
<h2>Match-maker, match-maker, <a href="#id7"><span class="problematic" id="id8">`</span></a>make me a<a class="headerlink" href="#match-maker-match-maker-make-me-a" title="Link to this heading">¶</a></h2>
<p><cite>__match__</cite> &lt;<a class="reference external" href="https://www.youtube.com/watch?v=59Hj7bp38f8">https://www.youtube.com/watch?v=59Hj7bp38f8</a>&gt;`_…</p>
<p><a class="reference external" href="https://blogger.googleusercontent.com/img/a/AVvXsEjMxObGvaIvslDc98eA-L5NJPCh56mPTurCwLIsqKxY3BHmVUaXFKcXLdFJgNMG2Ag0MxL3Q4kagE0SAAIFH-KNhuSa3k6BL0sWhn5dWK1ro1DJy7FhPwVDaZKr1o0aToh_MTmnIKy6NAFZGSSfPj1CDSBlw1tdPoUm_R-N4Z-hMnRTl4M">![</a>](<a class="reference external" href="https://blogger.googleusercontent.com/img/a/AVvXsEjMxObGvaIvslDc98eA-L5NJPCh56mPTurCwLIsqKxY3BHmVUaXFKcXLdFJgNMG2Ag0MxL3Q4kagE0SAAIFH">https://blogger.googleusercontent.com/img/a/AVvXsEjMxObGvaIvslDc98eA-L5NJPCh56mPTurCwLIsqKxY3BHmVUaXFKcXLdFJgNMG2Ag0MxL3Q4kagE0SAAIFH</a>-
KNhuSa3k6BL0sWhn5dWK1ro1DJy7FhPwVDaZKr1o0aToh_MTmnIKy6NAFZGSSfPj1CDSBlw1tdPoUm_R-N4Z-hMnRTl4M)
—
A slide from Sullivan’s talk</p>
<p>The reception in the room to Sullivan’s ideas was positive; the consensus
seemed to be that there was clearly room for improvement in this area. Brandt
Bucher, <a class="reference external" href="https://www.youtube.com/watch?v=XpxTrDDcpPE">author of the original pattern matching implementation in Python
3.10</a>, concurred that this kind
of enhancement was needed. Łukasz Langa, meanwhile, said he’d received many
queries from users of other programming languages such as C#, asking how to
tackle this kind of problem.</p>
<p>The proposal for a <cite>__match__</cite> special method follows a pattern common in
Python’s data model, where double-underscore “dunder” methods are overridden
to provide a class with special behaviour. As such, it will likely be less
jarring, at first glance, to those new to the idea. Attendees of Sullivan’s
talk seemed, broadly, to slightly prefer the <cite>__match__</cite> proposal, and
Sullivan himself said he thought it “looked prettier”.</p>
<p>Jelle Zijlstra argued that the <cite>__match__</cite> dunder would provide an elegant
symmetry between the construction and destruction of objects. Brandt Bucher,
meanwhile, said he thought the usability improvements weren’t significant
enough to merit new syntax.</p>
<p>Nonetheless, the alternative proposal for new syntax also has much to
recommend it. Sullivan argued that having dedicated syntax to express the idea
of “applying” a function during pattern matching was more explicit. Mark
Shannon agreed, noting the similarity between this idea and features in the
Haskell programming language. “This is functional programming,” Shannon
argued. “It feels weird to apply <a class="reference external" href="https://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a> models to this.”</p>
<ul class="simple">
<li><ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="addendum-pattern-matching-resources-and-recipes">
<h2>Addendum: pattern-matching resources and recipes<a class="headerlink" href="#addendum-pattern-matching-resources-and-recipes" title="Link to this heading">¶</a></h2>
<p>In the meantime, while we wait for a PEP, there are plenty of innovative uses
of pattern matching springing up in the ecosystem. For further
reading/watching/listening, I recommend:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>“A perfect `match</cite>: The history, design and future of Python’s structural pattern matching” &lt;<a class="reference external" href="https://www.youtube.com/watch?v=XpxTrDDcpPE">https://www.youtube.com/watch?v=XpxTrDDcpPE</a>&gt;`_ – A talk by Brandt Bucher at PyCon 2022</p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=ZTvwxXL37XI">“Structural Pattern Matching in the Real World”</a> – A talk by Raymond Hettinger at Pycon Italia 2022</p></li>
<li><p><a href="#id10"><span class="problematic" id="id11">``</span></a>RegexMatcher` &lt;<a class="reference external" href="https://github.com/nedbat/adventofcode2022/blob/main/day07.py">https://github.com/nedbat/adventofcode2022/blob/main/day07.py</a>&gt;`_: a class integrating pattern matching with Python’s <cite>re</cite> module. A 2022 Advent of Code solution by Ned Batchelder.</p></li>
<li><p><a href="#id12"><span class="problematic" id="id13">``</span></a>approximately` &lt;<a class="reference external" href="https://stackoverflow.com/questions/72596436/how-to-perform-approximate-structural-pattern-matching-for-floats-and-complex">https://stackoverflow.com/questions/72596436/how-to-perform-approximate-structural-pattern-matching-for-floats-and-complex</a>&gt;`_: A way to compare <cite>float</cite> and <cite>complex</cite> numbers using pattern matching, while avoiding the <a class="reference external" href="https://docs.python.org/3/tutorial/floatingpoint.html">perils of floating-point arithmetic</a>. A StackOverflow Q&amp;A by Raymond Hettinger.</p></li>
<li><p><a class="reference external" href="https://gist.github.com/msullivan/7f533f927a4ba3fffd856cb0c9527106">“A few related schemes for implementing view patterns in Python”</a>: A gist by Michael Sullivan (from February 2023)</p></li>
</ul>
</div></blockquote>
</section>
</section>

<div class="section ablog__blog_comments">
  
  


<div class="section ablog__prev-next">
  <span class="ablog__prev">
    
    
    Previous:
    
    <a href="2023-05-the-python-language-summit-2023-making.html">
      
      <span>The Python Language Summit 2023: Making the Global Interpreter Lock Optional</span>
    </a>
    
  </span>
  <span class="ablog__spacer">&nbsp;</span>
  <span class="ablog__next">
    
    
    Next:
    
    <a href="2023-05-the-python-language-summit-2023-python.html">
      <span>The Python Language Summit 2023: Python on Mobile</span>
      
    </a>
    
  </span>
</div>

  
  
</div>

      </article>
      
    </main>
  </div><footer class="sy-foot">
  <div class="sy-foot-inner sy-container mx-auto">
    <div class="sy-foot-reserved md:flex justify-between items-center">
      <div class="sy-foot-copyright"><p>2024, Python Software Foundation</p>
  
  <p>
    Made with
    
    <a href="https://www.sphinx-doc.org/">Sphinx</a> and
    
    <a href="https://shibuya.lepture.com">Shibuya theme</a>.
  </p>
</div>
      <div class="sy-foot-socials"></div>
    </div>
  </div>
</footer>
      <script src="../../_static/documentation_options.js?v=8a448e45"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script src="../../_static/shibuya.js?v=3cc430e2"></script></body>
</html>